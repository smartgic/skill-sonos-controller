"""This file contains functions related to extra operations
and are called by the handle_* methods from __init__.py
"""

import json
import os
from pathlib import Path
import requests
from ovos_utils.log import LOG
from soco import exceptions
from soco import discover
from soco.discovery import by_name
from soco.music_library import MusicLibrary
from soco.music_services import MusicService
from .constants import (
    SUPPORTED_MUSIC_LIBRARY_CATEGORIES,
    URL_SHORTENER,
    SUPPORTED_SERVICES,
    REQUIRED_AUTHENTICATION,
    TOKEN_FILE,
    TOKEN_COLLECTION,
    HTTP_REQUEST_TIMEOUT,
)


def ping(self):
    """Check if URL shortener service is up and running. This will help to
    better handle error in case the service is down. Check GitHub issue for
    more information: https://tinyurl.com/57fp6dde

    :raises RequestException: Raise RequestException
    """
    try:
        if requests.get(URL_SHORTENER, timeout=HTTP_REQUEST_TIMEOUT).status_code == 200:
            return True
    except requests.exceptions.RequestException as err:
        LOG.error(err)
        self.speak_dialog("error.urlshortener")
        return False


def authentication(self):
    """Some music services require an authentication.

    :raises SoCoException: Raise SoCoException
    """
    # This path is required by SoCo Python library and can't be changed.
    token_file = os.getenv("HOME") + TOKEN_FILE

    if self.service in map(str.lower, set(REQUIRED_AUTHENTICATION)):
        service = self.service.title()
        if self.service.title() == "Tidal":
            service = "TIDAL"
        provider = MusicService(service)

        # Collect authenticated music services from token file if it exists.
        token_data = {}
        if Path(token_file).is_file():
            try:
                with open(token_file, encoding="utf-8") as data:
                    token_data = json.load(data)
            except IOError as err:
                LOG.error(err)

        # Check if the music service has been already authenticated.
        # Each music service has a service ID and this service ID is written
        # into the token file as key.
        authenticated = False
        if len(token_data) > 0:
            for service in token_data[TOKEN_COLLECTION]:
                if service.split("#")[0] == provider.service_id:
                    authenticated = True

        if not authenticated and self.code and ping(self):
            try:
                # Retrieve the link code based on the URL code configured
                # on home.mycroft.ai.
                req = requests.get(
                    URL_SHORTENER + "/" + self.code + "/info",
                    timeout=HTTP_REQUEST_TIMEOUT,
                )
                if "extras" not in req.json():
                    self.speak_dialog("error.code", data={"code": self.code})
                    return
                link_code = req.json()["extras"]["code"]
                link_device_id = req.json()["extras"]["device"]

                # SoCo second part of the authentication mechanism.
                provider.complete_authentication(link_code, link_device_id)

                # Delete the shortened URL from the database once the
                # authentication is successfully done.
                req = requests.delete(
                    URL_SHORTENER + "/" + self.code, timeout=HTTP_REQUEST_TIMEOUT
                )

                self.speak_dialog("sonos.authenticated")
            except exceptions.SoCoException as err:
                LOG.error(err)
        elif not authenticated and ping(self):
            try:
                # Retrieve the url, the code and the device ID.
                url = provider.begin_authentication()
                code = provider.link_code
                device_id = provider.link_device_id

                # URL shortening the music service authentication URL.
                # The skill will speak the URL code not the authentication
                # code generated by the service.
                payload = {"target": url, "extras": {"code": code, "device": device_id}}
                req = requests.post(
                    URL_SHORTENER, json=payload, timeout=HTTP_REQUEST_TIMEOUT
                )
                url_shorted = req.json()["link"]

                # Map the code with NATO
                data = {"slash": ". ".join(map(self.nato_dict.get, url_shorted)) + "."}
                LOG.info(f"sonos link code: {url_shorted}")
                self.speak_dialog("sonos.link_code", data={"code": data}, wait=True)
            except exceptions.SoCoException as err:
                LOG.error(err)


def discovery(self):
    """Discover Sonos devices registered on the local network and
    add the them to a list.
    https://tinyurl.com/kahwd11y

    :raises SoCoException: Raise SoCoException
    """
    try:
        self.speakers = discover()
    except exceptions.SoCoException as err:
        LOG.error(err)

    if not self.speakers:
        LOG.warning("unable to find sonos devices")
        self.speak_dialog("error.discovery")
    else:
        LOG.info(f"{len(self.speakers)} device(s) found")


def get_state(self, speaker):
    """Get the current playback state.
    https://tinyurl.com/5az3lcb5

    :param speaker: Speaker to check the playback state
    :type speaker: string
    :return: The current transport state
    :rtype: str
    :raises SoCoException: Raise SoCoException
    """
    try:
        device = by_name(speaker)
        if device:
            key = "current_transport_state"
            return device.get_current_transport_info()[key]
    except exceptions.SoCoException as err:
        LOG.error(err)
    return None


def get_category(self, service, category):
    """Check if a category is available for a specific service or library.
    https://tinyurl.com/1plj5lzv

    :param service: Music service to check the categories
    :type service: string
    :param category: Which category to check
    :type category: string
    :return: A music provider depending the service
    :rtype:
    """
    try:
        provider = None
        available_categories = None

        if service == "Music Library":
            provider = MusicLibrary()
            available_categories = SUPPORTED_MUSIC_LIBRARY_CATEGORIES
        else:
            provider = MusicService(service)
            available_categories = provider.available_search_categories

        for categories in available_categories:
            if category in categories:
                return provider
    except exceptions.SoCoException as err:
        LOG.error(err)

    LOG.warning(f"{category} category not found for {service} service")
    self.speak_dialog("error.category", data={"category": category, "service": service})
    return None


def subscribed_services(self):
    """Get a list of all subscribed music services.
    https://tinyurl.com/zu3ymsd9

    :return: A list of subscribed services
    :rtype: list
    :raises SoCoException: Raise SoCoException
    """
    try:
        # Commented until SoCo integrates this method back
        # self.services = MusicService.get_subscribed_services_names()
        self.services = [
            "Spotify",
            "Apple Music",
            "Amazon Music",
            "Deezer",
            "Plex",
            "Wolfgangs Music",
            "Music Library",
            "Tidal",
        ]
        return self.services
    except exceptions.SoCoException as err:
        LOG.error(err)


def check_speaker(self, speaker, bypass_coordinator=False):
    """Check if the speaker is part of the discovered speakers and checks
    if it's part of a group/zone.
    If the speaker is part of a group/zone then it retrieves the group
    coordinator.
    https://tinyurl.com/4chwrb6u

    :param speaker: Which speaker to looking for
    :type speaker: string
    :param bypass_coordinator: If enabled and if a speaker is part of a group
        then not only the coordinator of the group will be returned but all
        the speakers.
    :type bypass_coordinator: bool, optional
    :return: Speaker name
    :rtype: str
    :raises SoCoException: Raise SoCoException
    """
    try:
        # A return should be set after the "if" but it requires more testing.
        for device in self.speakers:
            if speaker in device.player_name.lower():
                if not bypass_coordinator:
                    if len(device.group.members) > 1:
                        coordinator = device.group.coordinator
                        return coordinator.player_name
                return device.player_name
    except exceptions.SoCoException as err:
        LOG.error(err)

    LOG.warning(f"{speaker} speaker not found")
    self.speak_dialog("error.speaker", data={"speaker": speaker})

    return None


def check_service(self, service):
    """Check if the spoken service is part of the supported services, if found
    then we are looking for it into the subscribed service. Once the service
    has been found into the both list then we are looking it requires an
    authentication.

    :param service: Music service to check
    :type service: string
    :return: Speaker name
    :rtype: str
    :raises SoCoException: Raise SoCoException
    """
    if service in map(str.lower, set(SUPPORTED_SERVICES)):
        for subscription in self.services:
            if service in subscription.lower():
                auth = map(str.lower, set(REQUIRED_AUTHENTICATION))
                if service in auth:
                    if not os.path.isfile(os.getenv("HOME") + TOKEN_FILE):
                        LOG.warning(f"{service} requires authentication")
                        self.speak_dialog("error.auth", data={"service": service})
                        return service
                return service

    LOG.error(f"{service} service not supported")
    self.speak_dialog("error.support", data={"service": service})

    return None


def run_command(self, command, speaker, state="playing", extras=None):
    """Execute command on Sonos device, if no speaker is spoken then
    the function will check for all the speakers that are playing
    music. Specific command is used for volume and play mode management.

    :param command: Command to execute, defaults to playing
    :type command: string
    :param speaker: Which speaker to apply the command
    :type speaker: string
    :param state: Current state on the speaker
    :type state: string, optional
    :param extras: Add extra values to the command
    :type extras: string, optional
    :raises SoCoException: Raise SoCoException
    """
    try:
        if speaker:
            device_name = check_speaker(self, speaker)
            if not device_name:
                return None
            device = by_name(device_name)
            if get_state(self, device.player_name) == state.upper():
                if command == "mode":
                    _mode(self, device, extras)
                elif command in ("stop", "pause"):
                    if _valid_music_source(self, device):
                        eval(f"device.{command}()")
                else:
                    eval(f"device.{command}()")
        else:
            for device in self.speakers:
                if get_state(self, device.player_name) == state.upper():
                    if command in "mode":
                        _mode(self, device, extras)
                    else:
                        # If the speaker if part of a group them we are retrieving
                        # the coordinator one. This will avoid the
                        # "can only be called/used on the coordinator" error message.
                        if len(device.group.members) > 1:
                            coordinator = device.group.coordinator.player_name
                            if coordinator == device.player_name:
                                if command in ("stop", "pause"):
                                    if _valid_music_source(self, device):
                                        eval(f"device.{command}()")
                                else:
                                    eval(f"device.{command}()")
                        else:
                            if command in ("stop", "pause"):
                                if _valid_music_source(self, device):
                                    eval(f"device.{command}()")
                            else:
                                eval(f"device.{command}()")
    except exceptions.SoCoException as err:
        LOG.error(err)


def volume(self, way, speaker, value):
    """Manage volume on Sonos devices, if no speaker is spoken then
    the function will check for all the speakers that are playing
    music.

    :param way: Which way the turn the volume
    :type way: string
    :param speaker: Which device to manage the volume
    :type speaker: string
    :param value: Value to increase or decrease
    :type value: int
    :raises SoCoException: Raise SoCoException
    """
    try:
        if speaker:
            device_name = check_speaker(self, speaker, True)
            if not device_name:
                return None
            device = by_name(device_name)
            if way == "vol-up":
                device.volume += value
            elif way == "vol-down":
                device.volume -= value
        else:
            for device in self.speakers:
                if way == "vol-up":
                    device.volume += value
                elif way == "vol-down":
                    device.volume -= value
                elif way == "unduck":
                    if len(self.current_volume) > 0:
                        device.volume = self.current_volume[device.player_name]
    except exceptions.SoCoException as err:
        LOG.error(err)


def get_volume(self):
    """Get current volume value from all Sonos devices.

    This function is mainly used to handle the duck/unduck handler which
    will provide a better experience by restoring the right volume value.

    :raises SoCoException: Raise SoCoException
    """
    try:
        for device in self.speakers:
            self.current_volume[device.player_name] = device.volume
            LOG.debug(f"volume set to {device.volume} for {device.player_name} speaker")
    except exceptions.SoCoException as err:
        LOG.error(err)


def get_track_info(self, speaker, artist_only=False):
    """Retrieve information about the current playing track on speakers.

    :param speaker: Which device to manage the volume
    :type speaker: string
    :param artist_only: Return only the artist
    :type artist_only: bool
    :raises SoCoException: Raise SoCoException
    """
    try:
        if speaker:
            device_name = check_speaker(self, speaker)
            if not device_name:
                return None
            device = by_name(device_name)
            if get_state(self, device.player_name) == "PLAYING":
                if artist_only:
                    self.speak(device.get_current_track_info()["artist"])
                else:
                    self.speak_dialog(
                        "sonos.playing",
                        data={
                            "title": device.get_current_track_info()["title"],
                            "artist": device.get_current_track_info()["artist"],
                        },
                    )
            else:
                self.speak_dialog("sonos.nothing.playing")
        else:
            LOG.debug("> get_track_info() - speaker not detected")
            nothing_playing = True
            for device in self.speakers:
                if get_state(self, device.player_name) == "PLAYING":
                    if artist_only:
                        if device.get_current_track_info()["artist"]:
                            self.speak_dialog(
                                "sonos.playing.artist.on",
                                data={
                                    "artist": device.get_current_track_info()["artist"],
                                    "speaker": device.player_name,
                                },
                            )
                    else:
                        if device.get_current_track_info()["title"]:
                            self.speak_dialog(
                                "sonos.playing.on",
                                data={
                                    "title": device.get_current_track_info()["title"],
                                    "artist": device.get_current_track_info()["artist"],
                                    "speaker": device.player_name,
                                },
                            )
                    nothing_playing = False
            if nothing_playing:
                self.speak_dialog("sonos.nothing.playing")
    except exceptions.SoCoException as err:
        LOG.error(err)


def _valid_music_source(self, speaker):
    """Check the current music source of a speaker to avoid 701 error
    type when running some commands.

    :param speaker: Which device to retrieve the music source
    :type speaker: string
    :raises SoCoException: Raise SoCoException
    """
    try:
        if speaker.is_playing_tv or speaker.is_playing_line_in:
            msg = (
                f"unsupported action on {speaker.player_name} speaker when music "
                "source is tv or line-in"
            )
            LOG.warning(msg)
            return False
    except exceptions.SoCoException as err:
        LOG.error(err)
    return True


def _mode(self, speaker, value):
    """Manage play mode on Sonos devices.

    :param speaker: Which device to manage the mode
    :type speaker: string
    :param value: Value to set the mode
    :type value: string
    :raises SoCoException: Raise SoCoException
    """
    try:
        speaker.play_mode = value.upper()
    except exceptions.SoCoException as err:
        LOG.error(err)


def speaker_info(self, speaker, detailed=False):
    """Retrieve Sonos speaker information

    :param speaker: Which speaker to retrieve information
    :type speaker: string
    :param detailed: Return detailed information
    :type detailed: bool, optional
    :raises SoCoException: Raise SoCoException
    """
    try:
        device_name = check_speaker(self, speaker, True)
        if not device_name:
            return None
        device = by_name(device_name)
        info = device.get_speaker_info()
        model_name = info["model_name"].split(" ")[1].replace(":", " ")
        if detailed:
            self.speak_dialog(
                "sonos.speaker.info.detailed",
                data={
                    "model_name": model_name,
                    "model_number": info["model_number"],
                    "display_version": info["display_version"],
                    "uid": info["uid"],
                    "serial_number": info["serial_number"],
                    "software_version": info["software_version"],
                    "hardware_version": info["hardware_version"],
                    "mac_address": info["mac_address"],
                },
            )
        else:
            self.speak_dialog(
                "sonos.speaker.info",
                data={
                    "model_name": model_name,
                    "model_number": info["model_number"],
                    "display_version": info["display_version"],
                },
            )
    except exceptions.SoCoException as err:
        LOG.error(err)


def is_speaker_muted(self, speaker):
    """Check if the speaker is muted and play a message if it is

    :param speaker: Which speaker to retrieve the volume
    :type speaker: string
    """
    if speaker.volume == 0:
        LOG.debug(f"speaker {speaker.player_name} is muted")
        self.speak_dialog(
            "sonos.speaker.muted",
            data={
                "speaker": speaker.player_name,
            },
        )
